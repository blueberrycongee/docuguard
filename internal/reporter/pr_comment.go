package reporter

import (
	"fmt"
	"strings"

	"github.com/blueberrycongee/docuguard/pkg/types"
)

// FormatPRComment formats a PR check report as a GitHub comment.
func FormatPRComment(report *types.PRReport, repoURL string) string {
	var sb strings.Builder

	sb.WriteString("## DocuGuard Check Report\n\n")

	if len(report.Results) == 0 {
		sb.WriteString("No documentation-code inconsistencies found.\n\n")
		sb.WriteString(fmt.Sprintf("- Changed symbols: **%d**\n", report.TotalSymbols))
		sb.WriteString(fmt.Sprintf("- Document segments scanned: **%d**\n", report.TotalSegments))
		sb.WriteString(fmt.Sprintf("- Execution time: **%d** ms\n", report.ExecutionTimeMs))
	} else {
		inconsistentCount := 0
		for _, r := range report.Results {
			if !r.Consistent {
				inconsistentCount++
			}
		}

		if inconsistentCount > 0 {
			sb.WriteString(fmt.Sprintf("Found **%d** potential documentation issue(s):\n\n", inconsistentCount))
			sb.WriteString("### Inconsistencies\n\n")
			sb.WriteString("| Document | Code | Issue |\n")
			sb.WriteString("|----------|------|-------|\n")

			for _, r := range report.Results {
				if !r.Consistent {
					docLink := formatDocLink(r.Segment.File, r.Segment.StartLine, repoURL)
					sb.WriteString(fmt.Sprintf("| %s | `%s` | %s |\n",
						docLink,
						r.Symbol.Name,
						truncate(r.Reason, 50),
					))
				}
			}
			sb.WriteString("\n")
		}

		suggestCount := len(report.Results) - inconsistentCount
		if suggestCount > 0 {
			sb.WriteString("### Suggested Review\n\n")
			sb.WriteString("| Document | Related Code | Reason |\n")
			sb.WriteString("|----------|--------------|--------|\n")

			for _, r := range report.Results {
				if r.Consistent {
					docLink := formatDocLink(r.Segment.File, r.Segment.StartLine, repoURL)
					sb.WriteString(fmt.Sprintf("| %s | `%s` | %s |\n",
						docLink,
						r.Symbol.Name,
						truncate(r.Reason, 50),
					))
				}
			}
			sb.WriteString("\n")
		}
	}

	sb.WriteString("---\n")
	sb.WriteString("<sub>Generated by [DocuGuard](https://github.com/blueberrycongee/docuguard)</sub>\n")

	return sb.String()
}

// FormatPRCommentCompact formats a compact PR comment.
func FormatPRCommentCompact(report *types.PRReport) string {
	var sb strings.Builder

	sb.WriteString("## DocuGuard\n\n")

	if report.Inconsistent == 0 {
		sb.WriteString("Documentation and code are consistent.\n")
	} else {
		sb.WriteString(fmt.Sprintf("Found %d inconsistency(ies)\n\n", report.Inconsistent))

		for _, r := range report.Results {
			if !r.Consistent {
				sb.WriteString(fmt.Sprintf("- **%s** / `%s`: %s\n",
					r.Segment.Heading,
					r.Symbol.Name,
					r.Reason,
				))
			}
		}
	}

	return sb.String()
}

// formatDocLink formats a documentation link.
func formatDocLink(file string, line int, repoURL string) string {
	if repoURL != "" {
		return fmt.Sprintf("[%s#L%d](%s/blob/HEAD/%s#L%d)", file, line, repoURL, file, line)
	}
	return fmt.Sprintf("%s#L%d", file, line)
}

// truncate truncates a string to the specified length.
func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

// FormatDetailedResult formats a detailed result for review comments.
func FormatDetailedResult(result types.PRCheckResult) string {
	var sb strings.Builder

	sb.WriteString("### DocuGuard: Potential Issue\n\n")
	sb.WriteString(fmt.Sprintf("**Related Document**: %s (line %d)\n\n", result.Segment.File, result.Segment.StartLine))
	sb.WriteString(fmt.Sprintf("**Heading**: %s\n\n", result.Segment.Heading))
	sb.WriteString(fmt.Sprintf("**Issue**: %s\n\n", result.Reason))

	if result.Suggestion != "" {
		sb.WriteString(fmt.Sprintf("**Suggestion**: %s\n", result.Suggestion))
	}

	return sb.String()
}
